var hdkey = require('hdkey');
var ethUtil = require('ethereumjs-util');
var Mnemonic = require('../mnemonic');
var util = require('../util');

const { ETH_DERIVATION_PATH } = require('./const');

var Deriver = function () { }


/**
 * Generate a root path
 * @function generateRootPath
 * @param networkId - Ethereum network ID, i.e, 4 for Rinkeby, 1 for Mainnet
 * @param orgnazationName - Organization name. For example: 'Kambria'
 */
Deriver.generateRootPath = function (networkId, orgnazationName) {
  // Full path: m/<base>/<net>/<org>/<bnbAddressPath>
  let organization = util.stringToPath(orgnazationName);
  let path = {
    base: ETH_DERIVATION_PATH,
    net: networkId,
    org: organization,
    concat: function (extraPath) {
      let dpath = util.addDPath(util.addDPath(this.base, this.net), this.org);
      if (extraPath) dpath = util.addDPath(dpath, extraPath);
      return dpath;
    }
  }
  return path;
}

/**
 * Generate a root node
 * Because this function will include private key of root node
 * So you must manually delete private key before publication.
 * You must only use it when you are in intention of 2-way swap.
 * @function generateRootNode
 * @param mnemonic - Mnemonic
 * @param passwork - Passwork. It should be null to ignore.
 * @param rootPath - rootPath object
 */
Deriver.generateRootNode = function (mnemonic, passwork, rootPath) {
  console.warn(`
    You should use this function in BEP2-ERC20 swap.
    If you plan to do ERC20-BEP2 swap, please use generateSecureRootNode instead.
  `);
  let seed = Mnemonic.mnemonicToSeed(mnemonic, passwork);
  let master = hdkey.fromMasterSeed(seed);
  if (typeof rootPath === 'object') rootPath = rootPath.concat();
  let root = master.derive(rootPath);
  return root;
}

/**
 * Generate a deposite node
 * Because this function will include private key of deposit node
 * So you must manually delete private key before publication.
 * You must only use it when you are in intention of 2-way swap.
 * @function generateDepositNode
 * @param root - root node
 * @param bnbAddress - BNB Address
 */
Deriver.generateDepositNode = function (root, bnbAddress) {
  console.warn(`
    You should use this function in BEP2-ERC20 swap.
    If you plan to do ERC20-BEP2 swap, please use generateDepositSecureNode instead.
  `);
  let dpath = util.stringToPath(bnbAddress);
  let child = root.derive(util.addDPath('m/', dpath));
  return child;
}

/**
 * Securely generate a root node
 * We strongly recommend to use this function
 * @function generateSecureRootNode
 * @param mnemonic - Mnemonic
 * @param passwork - Passwork. It should be null to ignore.
 * @param rootPath - rootPath object
 */
Deriver.generateSecureRootNode = function (mnemonic, passwork, rootPath) {
  let seed = Mnemonic.mnemonicToSeed(mnemonic, passwork);
  let master = hdkey.fromMasterSeed(seed);
  if (typeof rootPath === 'object') rootPath = rootPath.concat();
  let root = master.derive(rootPath);
  delete root._privateKey;
  return { publicKey: ethUtil.bufferToHex(root.publicKey), chainCode: ethUtil.bufferToHex(root.chainCode) };
}

/**
 * Securely generate a deposite node
 * We strongly recommend to use this function
 * @function generateSecureDepositNode
 * @param root - root node generated by generateSecureRootNode
 * @param bnbAddress - BNB Address
 */
Deriver.generateSecureDepositNode = function (root, bnbAddress) {
  let bnbAddressPath = util.stringToPath(bnbAddress);
  let child = util.deriveChild(root.publicKey, root.chainCode, bnbAddressPath);
  let address = ethUtil.bufferToHex(ethUtil.pubToAddress(child.publicKey, true));
  return {
    bnbAddress: bnbAddress,
    dpath: bnbAddressPath,
    ethAddress: address
  }
}

/**
 * Validate deposit node
 * @function validateSecureDepositNode
 * @param root - root node generated by generateSecureRootNode
 * @param depositNode - the deposit node returned by generateSecureDepositNode
 */
Deriver.validateSecureDepositNode = function (root, depositNode) {
  if (!util.isValidEthAddress(depositNode.ethAddress)) return false;
  if (!util.isValidBnbAddress(depositNode.bnbAddress)) return false;

  let validDepositNode = Deriver.generateSecureDepositNode(root, depositNode.bnbAddress);
  let keys = Object.keys(validDepositNode);
  for (let i = 0; i < keys.length; i++) {
    if (validDepositNode[keys[i]] !== depositNode[keys[i]]) return false;
  }
  return true;
}

module.exports = Deriver;